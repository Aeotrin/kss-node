#!/usr/bin/env node

var kss = require(__dirname + '/../lib/kss.js'),
	handlebars = require('handlebars'),
	yargs = require('yargs'),
	marked = require('marked'),
	wrench = require('wrench'),
	glob = require('glob'),
	path = require('path'),
	fs = require('fs'),
	generator,
	template,
	init,
	generate,
	generatePage,
	configFile = {},
	configPath,
	KSS_FAILED = false,
	generatorConfig,
	error,
	version = require(__dirname + '/../package.json').version,
	resolveArray;

/**
 * Applies path.resolve() to the given path or array of paths.
 *
 * @param {string}        from  Optional path to resolve the "to" path
 * @param {string|array}  to    Relative path(s) to resolve.
 *
 * @return An absolute path.
 */
resolveArray = function(from, to) {
  var paths = [];
  // "from" is optional.
  if (typeof to === "undefined") {
    to = from;
    from = '';
  }
  if (to instanceof Array) {
    to.forEach(function(value, index) {
      paths[index] = path.resolve(from, value);
    });
  }
  else {
    paths = path.resolve(from, to);
  }
  return paths;
};

/**
 * Generator configruation.
 * @type {Object}
 */
generatorConfig = yargs
  .usage('Usage: kss-node <source> [destination] [options]')
  .wrap(80)
  .strict()

  .options('init', {
    alias     : 'i',
    describe  : 'Create a new style guide template to customize',
    default   : 'styleguide-template'
  })
  .options('template', {
    string    : true,
    alias     : 't',
    describe  : 'Use a custom template to build your style guide',
    default   : path.relative(process.cwd(), __dirname + '/../generators/handlebarsGenerator/template')
  })
  .options('helpers', {
    string    : true,
    describe  : 'Specify the location of custom handlebars helpers; see http://bit.ly/kss-helpers',
    default   : path.relative(process.cwd(), __dirname + '/../generators/handlebarsGenerator/template/helpers')
  })

  .options('mask', {
    string    : true,
    alias     : 'm',
    describe  : 'Use a mask for detecting files containing KSS comments',
    default   : '*.css|*.less|*.sass|*.scss|*.styl|*.stylus'
  })

  .options('css', {
    string    : true,
    describe  : 'Specify the URL of a CSS file to include in the style guide'
  })
  .options('js', {
    string    : true,
    describe  : 'Specify the URL of a JavaScript file to include in the style guide'
  })

  .options('custom', {
    string    : true,
    describe  : 'Process a custom property name when parsing KSS comments'
  })

  .options('source', {
    string    : true,
    describe  : 'Source directory to parse for KSS comments'
  })
  .options('destination', {
    string    : true,
    describe  : 'Destination directory of generated style guide',
    default   : 'styleguide'
  })

  .config('config')
  .alias('config', 'c')
  .describe('config', 'Load the kss-node configuration from a json file')

  .options('xdemo', {
    boolean   : true,
    // Alias is redundant, but prevents "Unknown argument: xdemo" error.
    alias     : 'xdemo'
  })

  .version(version, 'version')
  .help('help')
  .alias('help', 'h')
  .alias('help', '?')
  .argv;

// Help determine which options are specified in a config json file by loading
// the json file.
if (generatorConfig.config) {
  // Make config paths relative to config file.
  configPath = path.resolve(generatorConfig.config);
  configFile = require(configPath);
  configPath = path.dirname(configPath);
}

// Ensure these options are not an array.
["destination", "template", "helpers"].forEach(function(key) {
  // Only use the first value specified, ignoring the others.
  if (generatorConfig[key] instanceof Array) {
    generatorConfig[key] = generatorConfig[key].pop();
  }
  if (configFile[key] instanceof Array) {
    configFile[key] = configFile[key].pop();
  }
});

// Explicitly check if the --init option was called since generatorConfig.init
// will contain a default value.
if ("init" in yargs.argv || "i" in yargs.argv) {
  // Use the default value if --init is not given a path.
  if (typeof generatorConfig.init === "boolean") {
    generatorConfig.init = 'styleguide-template';
  }
}
else {
  delete generatorConfig.init;
}

// Get the full source path.
if (generatorConfig.xdemo) {
  generatorConfig.source = [__dirname + '/../demo'];
  generatorConfig.css = ['public/styles.css'];
}
else {
  if (!generatorConfig.source) {
    generatorConfig.source = [];
  }
  if (generatorConfig._.length > 0) {
    generatorConfig.source.push(generatorConfig._[0]);
  }
}

// Check if the destination is the second unnamed parameter.
if (!("destination" in yargs.argv) && generatorConfig._.length > 1) {
  generatorConfig.destination = generatorConfig._[1];
}

// Don't use the default value if the helpers option is not specified.
if (!("helpers" in yargs.argv) && !configFile.helpers) {
  generatorConfig.helpers = generatorConfig.template + '/helpers';
}

// Ensure these options are an array.
["source", "custom", "css", "js"].forEach(function(key) {
  if (typeof generatorConfig[key] === "string") {
    generatorConfig[key] = [generatorConfig[key]];
  }
  if (typeof configFile[key] === "string") {
    configFile[key] = [configFile[key]];
  }
});

// Resolve any paths relative to the config file or to the working directory.
["init", "template", "helpers", "source", "destination"].forEach(function(key) {
  if (typeof configFile[key] !== "undefined") {
    generatorConfig[key] = resolveArray(configPath, configFile[key]);
  }
  else if (typeof generatorConfig[key] !== "undefined") {
    generatorConfig[key] = resolveArray(generatorConfig[key]);
  }
});


// If no source is specified, display help and exit.
if (!generatorConfig.source.length && !generatorConfig.init) {
  yargs.showHelp();
  return;
}

// Load the template's generator.
try {
  // @TODO: The following line will always fail while testing a git clone of
  // this module. In order for a bundled template to be "clone"-able, it must
  // use the require('kss/generators/path') syntax (instead of the requiring a
  // relative path). Thus, when requiring its generator, the template will throw
  // an error since this kss module has been git cloned and not installed via
  // npm. This limitation will need to be fixed if additional generators are
  // added to the module.
  generator = require(generatorConfig.template).generator;
} catch (e) {
  // Templates don't have to load their own generator. If the template fails to
  // load a generator, we assume it wanted the default generator.
  generator = require('../generators/handlebarsGenerator');
};

// Clone a template.
if (generatorConfig.init) {
  console.log('Creating a new style guide template...');
  try {
    generator.clone(generatorConfig.template, generatorConfig.init);
  } catch (e) {
    console.log(e);
    return;
  }
  console.log('You can change it as you like, and use it with your style guide like so:');
  console.log('');
  console.log('kss-node [sourcedir] --template ' + generatorConfig.init);
  console.log('');
  return;
}

console.log('');
console.log('Generating your KSS style guide!');
console.log('');
console.log(' * KSS Source  : ' + generatorConfig.source.join(', '));
console.log(' * Destination : ' + generatorConfig.destination);
console.log(' * Template    : ' + generatorConfig.template);
console.log(' * Helpers     : ' + generatorConfig.helpers);
console.log('');

function init(source, destination, template, helpers) {
	var handlebarsTemplate;

	// Create a new destination directory.
	try {
		fs.mkdirSync(destination);
	} catch (e) {}

	// Optionally, copy the contents of the template's "public" folder.
	try {
		wrench.copyDirSyncRecursive(
			template + '/public',
			destination + '/public',
			{
				forceDelete: true,
				excludeHiddenUnix: true
			}
		);
	} catch (e) {}

	// Ensure a "public" folder exists.
	try {
		fs.mkdirSync(destination + '/public');
	} catch (e) {}

	// Load Handlebars helpers.
	if (fs.existsSync(helpers)) {
		// Load custom Handlebars helpers.
		var helperFiles = fs.readdirSync(helpers);

		helperFiles.forEach(function(fileName) {
			if (path.extname(fileName) !== '.js') {
				return;
			}
			var helper = require(helpers + '/' + fileName);
			if (typeof helper.register === 'function') {
				helper.register(handlebars);
			}
		});
	}

	// Load the standard Handlebars helpers.
	require(__dirname + '/../generators/handlebarsGenerator/helpers.js').register(handlebars);

	// Compile the Handlebars template.
	handlebarsTemplate = fs.readFileSync(template + '/index.html', 'utf8');
	handlebarsTemplate = handlebars.compile(handlebarsTemplate);

	return handlebarsTemplate;
};

template = init(generatorConfig.source, generatorConfig.destination, generatorConfig.template, generatorConfig.helpers);


// Generate the static HTML pages in the next tick, i.e. after the other functions have
// been defined and handlebars helpers set up.
process.nextTick(function() {
	console.log('...Parsing your style guide:');

	kss.traverse(generatorConfig.source, {
		multiline : true,
		markdown  : true,
		markup    : true,
		mask      : generatorConfig.mask,
		custom    : generatorConfig.custom
	}, function(err, styleguide) {
		if (err) throw err;
		generate(styleguide);
	});
});

function generate(styleguide) {
		var sections = styleguide.section(),
			sectionCount = sections.length,
			sectionRoots = [],
			rootCount,
			currentRoot,
			childSections = [],
			partials = {},
			partial,
			files = [],
			i;

		console.log(styleguide.data.files.map(function(file) {
			return ' - ' + file;
		}).join('\n'));

		// Throw an error if no KSS sections are found in the source files.
		if (sectionCount === 0) {
			throw 'No KSS documentation discovered in source files.';
		}

		console.log('...Determining section markup:');

		for (i = 0; i < sectionCount; i += 1) {
			// Register all the markup blocks as Handlebars partials.
			if (sections[i].markup()) {
				partial = {
					name: sections[i].reference(),
					reference: sections[i].reference(),
					file: '',
					markup: sections[i].markup(),
					data: {}
				};
				// If the markup is a file path, attempt to load the file.
				if (partial.markup.match(/^[^\n]+\.(html|hbs)$/)) {
					partial.file = partial.markup;
					partial.name = path.basename(partial.file, path.extname(partial.file));
					files = [];
					for (var key in generatorConfig.source) {
						if (!files.length) {
							files = glob.sync(generatorConfig.source[key] + '/**/' + partial.file);
						}
					}
					// If the markup file is not found, note that in the style guide.
					if (!files.length) {
						partial.markup += ' NOT FOUND!';
					}
					console.log(' - ' + partial.reference + ': ' + partial.markup);
					if (files.length) {
						// Load the partial's markup from file.
						partial.file = files[0];
						partial.markup = fs.readFileSync(partial.file, 'utf8');
						// Load sample data for the partial from the sample .json file.
						if (fs.existsSync(path.dirname(partial.file) + '/' + partial.name + '.json')) {
							try {
								partial.data = require(path.dirname(partial.file) + '/' + partial.name + '.json');
							} catch (e) {
								partial.data = {};
							}
						}
					}
				}
				else {
					console.log(' - ' + partial.reference + ': inline markup');
				}
				// Register the partial using the filename (without extension) or using
				// the style guide reference.
				handlebars.registerPartial(partial.name, partial.markup);
				// Save the name of the partial and its data for retrieval in the markup
				// helper, where we only know the reference.
				partials[partial.reference] = {
					name: partial.name,
					data: partial.data
				};
			}

			// Accumulate all of the sections' first indexes
			// in case they don't have a root element.
			currentRoot = sections[i].reference().split(/(?:\.|\s+\-\s+)/)[0];
			if (sectionRoots.indexOf(currentRoot) === -1) {
				sectionRoots.push(currentRoot);
			}
		}

		console.log('...Generating style guide sections:');

		// Now, group all of the sections by their root
		// reference, and make a page for each.
		rootCount = sectionRoots.length;
		for (i = 0; i < rootCount; i += 1) {
			childSections = styleguide.section(sectionRoots[i]+'.*');

			generatePage(styleguide, childSections, sectionRoots[i], sectionRoots, partials);
		}

		// Generate the homepage.
		childSections = [];
		generatePage(styleguide, childSections, 'styleguide.homepage', sectionRoots, partials);
};

// Renders the handlebars template for a section and saves it to a file.
generatePage = function(styleguide, sections, root, sectionRoots, partials) {
	var filename = '', files,
		homepageText = false,
		styles = '',
		scripts = '';

	if (root == 'styleguide.homepage') {
		filename = 'index.html';
		console.log(' - homepage');
		// Ensure homepageText is a non-false value.
		for (var key in generatorConfig.source) {
			if (!homepageText) {
				try {
					files = glob.sync(generatorConfig.source[key] + '/**/styleguide.md');
					if (files.length) {
						homepageText = ' ' + marked(fs.readFileSync(files[0], 'utf8'));
					}
				} catch (e) {}
			}
		}
		if (!homepageText) {
			homepageText = ' ';
			console.log('   ...no homepage content found in styleguide.md.');
		}
	}
	else {
		filename = 'section-' + kss.KssSection.prototype.encodeReferenceURI(root) + '.html';
		console.log(
			' - section '+root+' [',
			styleguide.section(root) ? styleguide.section(root).header() : 'Unnamed',
			']'
		);
	}
	// Create the HTML to load the optional CSS and JS.
	for (var key in generatorConfig.css) {
		styles = styles + '<link rel="stylesheet" href="' + generatorConfig.css[key] + '">\n';
	}
	for (var key in generatorConfig.js) {
		scripts = scripts + '<script src="' + generatorConfig.js[key] + '"></script>\n';
	}
	fs.writeFileSync(generatorConfig.destination + '/' + filename,
		template({
			partials:     partials,
			styleguide:   styleguide,
			sectionRoots: sectionRoots,
			sections:     sections.map(function(section) {
				return section.JSON(generatorConfig.custom);
			}),
			rootName:     root,
			argv:         generatorConfig || {},
			homepage:     homepageText,
			styles:       styles,
			scripts:      scripts
		})
	);
};

process.on('exit', function() {
	if (!KSS_FAILED) {
		console.log('');
		console.log('Generation completed successfully!');
		console.log('');
	}
});

process.on('uncaughtException', function(err) {
	console.log('\nError during generation\n');

	if (err.message || err.stack) {
		console.log(err.message);
		console.log(err.stack);
	}
	else
		console.log(err);

	KSS_FAILED = true;
	process.exit(1);
});
