'use strict';

var KssSection = require('./kss_section');

/**
 * The `kss/lib/kss_styleguide` module is normally accessed via the
 * [`KssStyleGuide()`]{@link module:kss.KssStyleGuide} constructor of the `kss`
 * module:
 * ```
 * var KssStyleGuide = require('kss').KssStyleGuide;
 * ```
 * @private
 * @module kss/lib/kss_styleguide
 */

var KssStyleGuide;

/**
 * An instance of this class is returned on finishing `kss.traverse`. It has a
 * few convenience methods for interpreting data, the most important of which is
 * sections() for searching for specific sections of the style guide.
 *
 * @constructor
 * @alias module:kss.KssStyleGuide
 * @param {Object} [data] The data object generated by traverse.
 */
KssStyleGuide = function(data) {
  if (!(this instanceof KssStyleGuide)) {
    return new KssStyleGuide(data);
  }

  var self = this;

  data = data || {};

  this.meta = {
    files: data.files || [],
    referenceDelimiter: '.',
    referenceMap: [],
    hasNumericReferences: true,
    weightMap: false
  };

  this.data = {
    customPropertyNames: data.customPropertyNames || [],
    sections: []
  };

  if (data.sections) {
    this.data.sections = data.sections.map(function(section) {
      if (!(section instanceof KssSection)) {
        section = new KssSection(section);
      }
      // Since the styleGuide property of the section is not set yet, manually
      // bubble-up the custom property names from the section into the style
      // guide.
      if (section.customPropertyNames()) {
        self.customPropertyNames(section.customPropertyNames());
      }
      // Determine if the references are number-based or word-based.
      self.meta.hasNumericReferences = self.meta.hasNumericReferences && /^[\.\d]+$/.test(section.reference());
      // Store the reference for quick searching later.
      self.meta.referenceMap[section.reference()] = section;
      // Set the style guide for each section. And return the section to .map().
      return section.styleGuide(self);
    });
  }

  this.init();
};

/**
 * Initializes the object and data passed to the constructor. Called
 * automatically from the KssStyleGuide() constructor; should not be called
 * directly.
 * @private
 */
KssStyleGuide.prototype.init = function() {
  var i, l, incrementIndex, autoIncrement = [0], ref, previousRef = [], index;

  // The map of section weights is created on the fly in getWeight().
  this.data.weightMap = false;

  if (this.data.sections.length) {
    // Determine the separator used in references; e.g. 'a - b' or 'a.b'.
    l = this.data.sections.length;
    for (i = 0; i < l; i += 1) {
      if (this.data.sections[i].reference().indexOf(' - ') > -1) {
        this.meta.referenceDelimiter = ' - ';
        break;
      }
    }

    // Set the depth of each section's reference.
    for (i = 0; i < l; i += 1) {
      this.data.sections[i].depth(this.data.sections[i].reference().split(this.meta.referenceDelimiter).length);
    }

    // Sort all the sections.
    this.sortSections();

    // Create an auto-incremented reference number if the references are not
    // number-based references.
    if (!this.hasNumericReferences()) {
      for (i = 0; i < l; i += 1) {
        ref = this.data.sections[i].reference();

        // Compare the previous Ref to the new Ref.
        ref = ref.split(this.meta.referenceDelimiter);
        // If they are already equal, we don't need to increment the section number.
        if (previousRef.join(this.meta.referenceDelimiter) !== ref.join(this.meta.referenceDelimiter)) {
          incrementIndex = 0;
          for (index = 0; index < previousRef.length; index += 1) {
            // Find the index where the refs differ.
            if (index >= ref.length || previousRef[index] !== ref[index]) {
              break;
            }
            incrementIndex = index + 1;
          }
          if (incrementIndex < autoIncrement.length) {
            // Increment the part where the refs started to differ.
            autoIncrement[incrementIndex]++;
            // Trim off the extra parts of the autoincrement where the refs differed.
            autoIncrement = autoIncrement.slice(0, incrementIndex + 1);
          }
          // Add parts to the autoincrement to ensure it is the same length as the new ref.
          for (index = autoIncrement.length; index < ref.length; index += 1) {
            autoIncrement[index] = 1;
          }
        }
        this.data.sections[i].referenceNumber(autoIncrement.join('.'));
        previousRef = ref;
      }
    }
  }
};

/**
 * Gets or sets the list of custom properties of the style guide.
 *
 * If the `names` value is provided, the names are added to the style guide's
 * list of custom properties. Otherwise, the style guide's list of custom
 * properties is returned.
 *
 * @param {string|string[]} [names] Optional. The names of  of the section.
 * @returns {KssStyleGuide|string[]} If `names` is given, the `KssStyleGuide`
 *   object is returned to allow chaining of methods. Otherwise, the list of
 *   custom properties of the style guide is returned.
 */
KssStyleGuide.prototype.customPropertyNames = function(names) {
  if (typeof names === 'undefined') {
    return this.data.customPropertyNames;
  }

  if (!(names instanceof Array)) {
    names = [names];
  }
  for (var i = 0; i < names.length; i++) {
    if (this.data.customPropertyNames.indexOf(names[i]) === -1) {
      this.data.customPropertyNames.push(names[i]);
    }
  }
  // Allow chaining.
  return this;
};

/**
 * Returns whether the style guide has numeric references or not.
 *
 * @returns {boolean} Whether the style guide has numeric references or not.
 */
KssStyleGuide.prototype.hasNumericReferences = function() {
  return this.meta.hasNumericReferences;
};

/**
 * Search for sections within the style guide.
 *
 * There's a few ways to use this method:
 * - `sections()` returns all of the sections.
 *
 * Using strings:
 * - `sections('2')` returns Section 2.
 * - `sections('2.*')` returns Section 2 and all of its descendants.
 * - `sections('2.x')` returns Section 2's children only.
 * - `sections('2.x.x')` returns Section 2's children, and their children too.
 *
 * Or Regular Expressions:
 * - `sections(/2\.[1-5]/)` returns Sections 2.1 through to 2.5.
 *
 * @param {string|Regexp} [sections] A string or Regexp object to match a KssSection's style guide reference.
 * @returns {false|KssSection|Array} The exact KssSection requested, an array of KssSection objects matching the query, or false.
 */
KssStyleGuide.prototype.sections = function(sections) {
  if (typeof sections === 'undefined') {
    return this.data.sections;
  }

  var query, i, l = this.data.sections.length,
    current, isRegexSearch, delim,
    matchedSections = [],
    match;

  query = sections;

  // Exact queries.
  if (typeof query === 'string') {
    // If the query is '*', 'x', or ends with '.*', ' - *', '.x', or ' - x',
    // then it is not an exact query.
    isRegexSearch = query.match(/(^[x\*]$|\s\-\s[x\*]$|\.[x\*]$)/);
    if (!isRegexSearch) {
      if (this.meta.referenceMap[query]) {
        return this.meta.referenceMap[query];
      } else {
        return false;
      }
    }
  }

  // Convert regex strings into proper JavaScript RegExp objects.
  if (!(query instanceof RegExp)) {
    delim = this.meta.referenceDelimiter === '.' ? '\\.' : '\\ \\-\\ ';
    query = new RegExp(
      query
        // Convert '*' to a simple .+ regex.
        .replace(/^\*$/, '.+')
        // Convert 'x' to a regex matching one level of reference.
        .replace(/^x$/, '^.+?(?=($|' + delim + '))')
        // Convert '.*' or ' - *' to a ([delim].+){0,1} regex.
        .replace(/(\.|\s+\-\s+)\*$/g, '(' + delim + '.+){0,1}')
        // Convert the first '.x' or ' - x' to a regex matching one sub-level
        // of a reference.
        .replace(/(\.|\s+\-\s+)x\b/, delim + '.+?(?=($|' + delim + '))')
        // Convert any remaining '.x' or ' - x' to a regex matching zero or one
        // sub-levels of a reference.
        .replace(/(\.|\s+\-\s+)x\b/g, '(' + delim + '.+?(?=($|' + delim + '))){0,1}')
        // Convert any remaining '-' into '\-'
        .replace(/([^\\])\-/g, '$1\\-')
    );
  }

  // General (regex) search
  for (i = 0; i < l; i += 1) {
    current = this.data.sections[i];
    match = current.reference().match(query);
    if (match && match[0] === current.reference()) {
      matchedSections.push(current);
    }
  }

  return matchedSections;
};

/**
 * Sorts the sections of the style guide.
 *
 * This is called automatically when the {@link KssStyleGuide} object is
 * created, but is publicly accessible as well.
 */
KssStyleGuide.prototype.sortSections = function() {
  var self = this;

  // Sort sections based on reference number.
  this.data.sections.sort(function(a, b) {
    // Split the 2 references into chunks by their period or dash separators.
    var refsA = a.reference().toLowerCase().split(self.meta.referenceDelimiter),
      refsB = b.reference().toLowerCase().split(self.meta.referenceDelimiter),
      weightA, weightB,
      i, l = Math.max(refsA.length, refsB.length);

    // Compare each set of chunks until we know which reference should be listed first.
    for (i = 0; i < l; i += 1) {
      if (refsA[i] && refsB[i]) {
        // If the 2 chunks are unequal, compare them.
        if (refsA[i] !== refsB[i]) {
          // If the chunks have different weights, sort by weight.
          weightA = self.getWeight(a.reference(), i);
          weightB = self.getWeight(b.reference(), i);
          if (weightA !== weightB) {
            return weightA - weightB;
          } else if (refsA[i].match(/^\d+$/) && refsB[i].match(/^\d+$/)) {
            // If both chunks are digits, use numeric sorting.
            return refsA[i] - refsB[i];
          } else {
            // Otherwise, use alphabetical string sorting.
            return (refsA[i] > refsB[i]) ? 1 : -1;
          }
        }
      } else {
        // If 1 of the chunks is empty, it goes first.
        return refsA[i] ? 1 : -1;
      }
    }

    return 0;
  });
};

/**
 * Helper function for `KssStyleGuide.sortSections()` that gets the weight of
 * the given reference at the given depth.
 *
 * For example, `styleGuide.getWeight('4.3.2.2', 2)` will return the weight for
 * section 4.3.
 *
 * @param {string} reference A section reference.
 * @param {int} [depth] The requested depth (optional).
 * @returns {int} The requested weight.
 */
KssStyleGuide.prototype.getWeight = function(reference, depth) {
  // Initialize the map of weights.
  if (this.meta.weightMap === false) {
    this.meta.weightMap = {};
    for (var key in this.data.sections) {
      /* istanbul ignore else */
      if (this.data.sections.hasOwnProperty(key)) {
        this.meta.weightMap[this.data.sections[key].reference().toLowerCase()] = this.data.sections[key].weight();
      }
    }
  }

  reference = reference.toLowerCase();
  if (typeof depth !== 'undefined') {
    reference = reference.split(this.meta.referenceDelimiter, depth + 1).join(this.meta.referenceDelimiter);
  }

  return this.meta.weightMap[reference] ? this.meta.weightMap[reference] : 0;
};

module.exports = KssStyleGuide;
